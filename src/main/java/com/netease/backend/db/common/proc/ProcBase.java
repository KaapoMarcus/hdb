package com.netease.backend.db.common.proc;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import org.apache.log4j.Logger;


public class ProcBase extends SimpleProcBase implements Proc {

	
	private static final int DEFAULT_PROC_TERM_AWAIT_TIME = 10000 ;
	
	private static final int DEFAULT_PROC_START_AWAIT_TIME = 3000 ;

	
	private ExecutorService executor = null;
	
	private int procTermAwaitTime = DEFAULT_PROC_TERM_AWAIT_TIME;

	
	private final Map<String, Proc> managedProcs;

	private boolean isDaemon = false;

	
	public ProcBase() {
		super();
		managedProcs = Collections.synchronizedMap(new HashMap<String, Proc>());
	}

	public ProcBase(String name, boolean daemon) {
		super(name, daemon);
		this.isDaemon = daemon;
		managedProcs = Collections.synchronizedMap(new HashMap<String, Proc>());
	}

	
	protected static final void checkIfRunning(ProcBase proc) {
		if (!proc.isRunning())
			throw new IllegalStateException(proc.getName() + "δ���л����˳���");
	}

	
	protected static final void awaitAndCheckIfRunning(ProcBase proc) {
		if (!proc.awaitRunning())
			throw new IllegalStateException(proc.getName() + "δ���л����˳���");
	}

	
	protected static final void awaitAndCheckIfStarted(ProcBase proc) {
		if (!proc.awaitRunning()) {
			if (!proc.isShutdown())
				throw new IllegalStateException(proc.getName() + "δ������ɣ�");
		}
	}

	
	@Override
	public void run() {
		PROC: try {
			if (!this.runInit() || !this.runStart()) {
				break PROC;
			}
			this.doRun();
			this.runShutdownAnyway();
		} finally {
			this.runDispose();
		}
	}

	volatile private int state = INITIAL;
	private static final int INITIAL = 0x0;
	private static final int INIT = 0x1;
	private static final int INITD = 0x2;
	private static final int INITFAILED = 0x3;
	private static final int START = 0x4;
	private static final int RUNNING = 0x5;
	private static final int SHUTDOWN = 0x6;
	private static final int TERMINATED = 0x7;

	
	
	private final Lock lock = new ReentrantLock();
	private final Condition cond = lock.newCondition();

	
	public boolean isInitd() {
		return this.state >= INITD;
	}
	
	
	public boolean isInitFailed() {
		return this.state == INITFAILED;
	}

	
	public boolean isStarted() {
		return this.state >= RUNNING;
	}

	
	public boolean isRunning() {
		return this.state == RUNNING;
	}

	
	public boolean isTerminated() {
		return this.state == TERMINATED;
	}

	
	public boolean isShutdown() {
		final int state = this.state;
		return (state == SHUTDOWN) || (state == TERMINATED);
	}

	
	private boolean awaitRunning() {
		for (;;) {
			if (this.isShutdown() || this.isInitFailed())
				return false;
			if (this.isRunning())
				return true;

			final Lock lock = this.lock;
			lock.lock();
			final int state = this.state;
			try {
				if (state < RUNNING) {
					cond.await(DEFAULT_PROC_START_AWAIT_TIME,
							TimeUnit.MILLISECONDS);
				}
			} catch (final InterruptedException ex) {
				return false; 
			} finally {
				lock.unlock();
			}
		}
	}

	
	private boolean runInit() {
		boolean initd = false;

		final Lock lock = this.lock;
		lock.lock();
		final int state = this.state;
		boolean acted = false;
		ACT: try {
			if (state != INITIAL) {
				break ACT;
			}
			this.state = INIT; 
			initd = this.doRunInit();
			acted = true;
		} finally {
			if (!acted) { 
				this.state = state;
			}
			lock.unlock();
		}

		return initd;
	}

	
	private boolean doRunInit() {
		final String name = this.getName();
		final Logger logger = this.getLogger();

		final int state = this.state;
		boolean initd = false;
		ACT: try {
			if (state != INIT) {
				break ACT;
			}
			this.initExecutor();
			this.initAction();
			initd = true;
			logger.info(name + "��ʼ�����");
		} catch (final RuntimeException ex) {
			throw ex;
		} catch (final Exception ex) {
			
			this.tryInitdFailed();
			logger.error(name + "��ʼ������", ex);
		} finally {
			
			this.tryInitd(); 
			
		}
		return initd;
	}

	
	private void tryInitd() {
		if (this.state == INIT) {
			this.state = INITD;
		}
	}
	
	private void tryInitdFailed() {
		if (this.state == INIT) {
			this.state = INITFAILED;
		}
	}

	
	protected void initAction() throws Exception {
		
	}

	private void initExecutor() {
		executor = Executors.newCachedThreadPool(new PoolThreadFactory(
				"pooled thread generated by " + this.getName(), isDaemon));
	}

	
	private boolean runStart() {
		boolean started = false;

		final Lock lock = this.lock;
		lock.lock();
		final int state = this.state;
		boolean acted = false;
		ACT: try {
			if ((state < INITD) || (state > START)) {
				
				break ACT;
			}
			this.state = START;
			started = this.doRunStart();
			acted = true;
		} finally {
			if (!acted) { 
				this.state = state;
			}
			lock.unlock();
		}

		return started;
	}

	
	private boolean doRunStart() {
		final int state = this.state;
		boolean started = false;
		ACT: try {
			if (state != START) {
				break ACT;
			}
			this.startManagedProcs();
			this.startAction();
			started = this.doAwaitStarted();
		} finally {
			if (started) {
				this.tryStarted();
			}
		}
		return started;
	}

	
	private void tryStarted() {
		if (this.state == START) {
			this.state = RUNNING;
			cond.signalAll();
		}
	}

	private boolean doAwaitStarted() {
		final Logger logger = this.getLogger();
		final String name = this.getName();
		try {
			this.awaitStartingAction();
			logger.info(name + "�������");
			return true;
		} catch (final InterruptedException ex) {
			logger.error(name + "�������̱��жϣ�");
		}
		return false;
	}

	
	protected void startAction() {
		
	}

	
	protected void awaitStartingAction() throws InterruptedException {
		
	}

	
	private void doRun() {
		final String name = this.getName();
		final Logger logger = this.getLogger();

		CORE: for (;;) {
			try {
				if (!this.runProc()) { 
					break CORE;
				}
			} catch (final RuntimeException ex) {
				
				logger.error(name + "��������ʱ���󣨼����˳�����", ex);
				break CORE; 
			} catch (final Throwable err) {
				logger.fatal(name + "�������ش��󣨼����˳�����", err);
				break CORE; 
			}
		}
	}

	
	protected boolean runProc() {
		
		return false;
	}

	
	protected final void scheduleTask(Runnable task) {
		final ExecutorService exec = this.getExecutor();
		if ((exec == null) || exec.isShutdown())
			throw new IllegalStateException(this.getName() + "����ִ����δ���������˳���");

		exec.submit(task);
	}

	@Override
	protected void invokeShutdown() {
		
		
		this.runShutdown(false);
		super.invokeShutdown();
	}

	private void runShutdownAnyway() {
		for (;;) {
			if (this.isTerminated() || !this.isStarted()
					|| this.runShutdown(true)) {
				break;
			}
		}
	}

	
	private boolean runShutdown(boolean await) {
		boolean terminated = false;

		final Lock lock = this.lock;
		lock.lock();
		final int state = this.state;
		boolean acted = false;
		ACT: try {
			if ((state < RUNNING) || (state == TERMINATED)) {
				break ACT;
			}
			
			this.state = SHUTDOWN;
			
			terminated = this.doRunShutdown(await);
			acted = true;
		} finally {
			if (!acted) { 
				this.state = state;
			}
			lock.unlock();
		}

		return terminated;

	}

	
	private boolean doRunShutdown(boolean await) {
		final String name = this.getName();
		final Logger logger = this.getLogger();

		boolean terminated = false;
		final int state = this.state;
		ACT: try {
			if (state != SHUTDOWN) {
				break ACT;
			}
			
			
			int i = 0;
			FOR: for (;;) {
				try {
					SWITCH: switch (i) {
					case 0:
						this.shutdownAction();
						break SWITCH;
					case 1:
						this.stopManagedProcs(true);
						break SWITCH;
					case 2:
						this.shutdownExecutor();
						break SWITCH;
					default:
						break FOR;
					}
				} catch (final InterruptedException ignored) {
				} catch (final Exception ex) {
					logger.error("�ر�" + name + "ʱ��������", ex);
				} finally {
					i++;
				}
			}
			if (await) {
				terminated = this.doAwaitTermination();
			} else {
				terminated = this.checkTerminationAction();
				logger.info(name + "���˳���");
			}
		} finally {
			if (terminated) {
				this.tryTerminated();
			}
		}
		return terminated;
	}

	
	private void tryTerminated() {
		if (this.state == SHUTDOWN) {
			this.state = TERMINATED;
		}
	}

	private boolean doAwaitTermination() {
		final Logger logger = this.getLogger();
		final String name = this.getName();
		try {
			this.awaitShuttingdownAction();
			logger.info(name + "���˳���");
			return true;
		} catch (final InterruptedException ignored) {
			logger.warn(name + "�رչ��̱��жϣ�");
		}

		return false;
	}

	
	protected void shutdownAction() {
		
	}

	
	protected void awaitShuttingdownAction() throws InterruptedException {
		
	}

	
	protected boolean checkTerminationAction() {
		return true;
	}

	
	private void shutdownExecutor() {
		final ExecutorService executor = this.getExecutor();
		if ((executor != null) && !executor.isTerminated()) {
			this.shutdownExecutor(executor);
		}
	}

	protected final void shutdownExecutor(ExecutorService executor) {
		
		try {
			
			executor.shutdown();
			
			final int ms = this.getProcTermAwaitTime();
			if (ms > 0) {
				try {
					executor.awaitTermination(ms, TimeUnit.MILLISECONDS);
				} catch (final InterruptedException ex) {
					
				}
			}
		} finally {
			
			if (!executor.isTerminated()) {
				executor.shutdownNow();
			}
		}
	}

	
	private void runDispose() {
		final String name = this.getName();
		final Logger logger = this.getLogger();

		logger.info("Disposing " + name + "����");
		int i = 0;
		
		
		ACT: for (;;) {
			try {
				switch (i) {
				case 0:
					this.disposeAction();
					break;
				case 1:
					this.disposeManagedProcs();
					break;
				case 2:
					this.disposeExecutor();
					break;
				default:
					break ACT;
				}
			} catch (final Exception ex) {
				logger.error(name + " Disposing error��", ex);
			} finally {
				i++;
			}
		}
		logger.info(name + " Disposed��");
	}

	
	protected void disposeAction() {
		
	}

	private void disposeManagedProcs() {
		final Map<String, Proc> procs = this.getManagedProcs();
		if (procs != null) {
			procs.clear();
		}
	}

	
	private void disposeExecutor() {
		
		executor = null;
	}

	
	private Map<String, Proc> getManagedProcs() {
		return managedProcs;
	}

	
	protected final void manageProcs(Proc... newProcs) {
		final Map<String, Proc> procs = this.getManagedProcs();
		if (procs != null) {
			for (final Proc proc : newProcs) {
				procs.put(proc.getName(), proc);
			}
		}
	}

	
	protected final void startManagedProcs() {
		final Map<String, Proc> procs = this.getManagedProcs();
		if (procs != null) {
			synchronized (procs) {
				for (final Proc proc : procs.values()) {
					proc.startup();
				}
			}
		}
	}

	
	protected final void stopManagedProcs(boolean join)
			throws InterruptedException {
		final Map<String, Proc> procs = this.getManagedProcs();
		if (procs != null) {
			synchronized (procs) {
				for (final Proc proc : procs.values()) {
					stopProc(proc);
				}
				if (join) {
					awaitProcsTermination(procs, this.getProcTermAwaitTime(),
							TimeUnit.MILLISECONDS);
				}
			}
		}
	}

	
	protected final boolean stopManagedProc(String name, boolean awaitTerminatd)
			throws InterruptedException {
		final Proc proc;
		if ((proc = this.getManagedProcs().get(name)) != null) {
			stopProc(proc, awaitTerminatd, this.getProcTermAwaitTime(),
					TimeUnit.MILLISECONDS);
			return true;
		}

		return false;
	}

	
	private static void awaitProcsTermination(Map<String, Proc> procs,
			int termAwaitTime, TimeUnit unit) throws InterruptedException {
		for (final Proc proc : procs.values()) {
			proc.awaitTermination(termAwaitTime, unit);
		}
	}

	
	public static void stopProc(Proc proc, boolean join, int termAwaitTime,
			TimeUnit unit) throws InterruptedException {
		proc.shutdown();
		if (join) {
			proc.awaitTermination(termAwaitTime, unit);
		}
	}

	
	public static void stopProc(Proc proc) {
		try {
			stopProc(proc, false, 0, null);
		} catch (final InterruptedException ex) {
		}
	}

	
	private ExecutorService getExecutor() {
		return executor;
	}

	
	public int getProcTermAwaitTime() {
		return procTermAwaitTime;
	}

	
	public void setProcTermAwaitTime(int procTermAwaitTime) {
		this.procTermAwaitTime = procTermAwaitTime;
	}

	
	public void startInternal(){
		this.state  = RUNNING;
	}
}
